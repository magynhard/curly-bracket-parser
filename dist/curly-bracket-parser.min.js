class CurlyBracketParser{static getVersion(){return CurlyBracketParser._version}static parse(string,variables={},options={unresolved_vars:"throw",replace_pattern:"##$1##"}){const self=CurlyBracketParser;if(!Typifier.isString(string))throw new Error(`Given parameter 'string' must be of type 'string'! It is of type ${Typifier.getType(string)}: ${string}\n`);options=options||{};const default_options={unresolved_vars:"throw",replace_pattern:"##$1##"};options=Object.assign(default_options,options),variables=variables||{};let result_string=string;if(self.isAnyVariableIncluded(string)){for(;;){for(let string_var of self.variables(result_string)){const decoded_var=self.decodeVariable(string_var),name=decoded_var.name||0===decoded_var.name?decoded_var.name:"''",filter=decoded_var.filter;let value=null;const is_single_quoted=name.startsWith("'")&&name.endsWith("'"),is_double_quoted=name.startsWith('"')&&name.endsWith('"');if(is_double_quoted||is_single_quoted)value=name.substring(1,name.length-1);else if(Typifier.isNumberString(name))value=eval(name);else if(variables.hasOwnProperty(name)||self._isTreeVariableString(name)&&self._hasTreeProperty(variables,name)){let e=null;e=self._isTreeVariableString(name)?self._extractTreeVariable(variables,name):variables[name],value=Typifier.isUndefined(e)||Typifier.isNaN(e)||Typifier.isNull(e)||Typifier.isInfinity(e)?"":e}else self.isRegisteredDefaultVar(name)&&(value=self.processDefaultVar(name));null!==value&&(filter&&(value=self.processFilter(filter,value)),result_string=self._replaceAll(result_string,string_var,value))}if(!self.isAnyVariableIncluded(result_string)||!self.includesOneVariableOf(Object.keys(variables),result_string))break}switch(options.unresolved_vars){case"throw":if(self.isAnyVariableIncluded(result_string))throw new UnresolvedVariablesError(`There are unresolved variables in the given string: ${self.variables(result_string)}`);break;case"replace":result_string=result_string.replace(self.VARIABLE_DECODER_REGEX,options.replace_pattern)}}return result_string}static parseFile(e,r={},t={unresolved_vars:"throw",replace_pattern:"##$1##",success:null,write:!1}){const s=CurlyBracketParser;if(t=t||{},t=Object.assign({unresolved_vars:"throw",replace_pattern:"##$1##",success:null,write:!1},t),r=r||{},s._runByNode()){const a=require("fs"),i=a.readFileSync(e,"utf-8").toString(),n=s.parse(i,r,t);return t.write&&a.writeFileSync(e,n),n}if(s._runByBrowser()){const a=`Could not retrieve file '${e}' by GET.`;if(t.success&&"function"==typeof t.success){const i=new XMLHttpRequest;return i.open("GET",e,!0),i.onload=function(e){if(4!==i.readyState)throw new FileNotRetrievedError(a);if(200!==i.status)throw new FileNotRetrievedError(a+"\n"+i.statusText);{const e=s.parse(i.responseText,r,t);t.success(e)}},i.send(null),null}{const i=new XMLHttpRequest;if(i.open("GET",e,!1),i.send(null),200===i.status)return s.parse(i.responseText,r,t);throw new FileNotRetrievedError(a+"\n"+i.statusText)}}}static parseFileWrite(e,r={},t={unresolved_vars:"throw",replace_pattern:"##$1##"}){const s=CurlyBracketParser;if((t=t||{}).write=!0,s._runByNode())return s.parseFile(e,r,t);throw"This method can only be run on node js, not in browser."}static registerFilter(e,r,t={raise_on_exist:!0}){const s=CurlyBracketParser;if(s.isValidFilter(e))throw new FilterAlreadyRegisteredError(`The given filter name '${e}' is already registered`);if("function"!=typeof r)throw`Given parameter 'filter_function' must be of type 'function'. It is of type '${typeof r}'.`;s.registered_filters[e]=r}static processFilter(e,r){const t=CurlyBracketParser;if(t.registered_filters[e])return t.registered_filters[e](r);if("undefined"!=typeof LuckyCase&&t.VALID_DEFAULT_FILTERS().includes(LuckyCase.toUpperCase(e))&&LuckyCase.isValidCaseType(LuckyCase.toUpperCase(e)))return LuckyCase.convertCase(r,LuckyCase.toUpperCase(e));{const r=`Invalid filter '${e}'. Valid filters are: ${t.validFilters().join(" ")}`;throw new InvalidFilterError(r)}}static validFilters(){const e=CurlyBracketParser,r=e.VALID_DEFAULT_FILTERS(),t=Object.keys(e.registered_filters),s=e.VALID_DEFAULT_FILTERS().map(e=>e.toLocaleLowerCase());return r.concat(t).concat(s)}static isValidFilter(e){return CurlyBracketParser.validFilters().includes(e)}static registerDefaultVar(e,r,t={overwrite:!1}){const s=CurlyBracketParser;t=t||{};if(t=Object.assign({unresolved_vars:"throw",replace_pattern:"##$1##"},t),s.isRegisteredDefaultVar(e)&&!1===t.overwrite){throw new VariableAlreadyRegisteredError(`The given variable name '${e}' is already registered. If you want to override that variable explicitly, use option 'overwrite: true'!`)}if("function"==typeof r)return s.registered_default_vars[e]=r;throw`Given parameter 'var_function' must be of type 'function'. It is of type '${typeof r}'.`}static processDefaultVar(e){const r=CurlyBracketParser;if(r.registered_default_vars[e])return r.registered_default_vars[e]();{const t=`Invalid default variable '${e}'. Valid registered default variables are: ${Object.keys(r.registered_default_vars).join(" ")}`;throw new InvalidVariableError(t)}}static unregisterDefaultVar(e){const r=CurlyBracketParser;return!!r.registered_default_vars[e]&&(delete r.registered_default_vars[e],!0)}static registeredDefaultVars(){const e=CurlyBracketParser;return Object.keys(e.registered_default_vars)}static isRegisteredDefaultVar(e){return CurlyBracketParser.registeredDefaultVars().includes(e)}static decodeVariable(e){return CurlyBracketParser.decodedVariables(e)[0]}static decodedVariables(e){const r=CurlyBracketParser;let t=[];for(r.VARIABLE_DECODER_REGEX.lastIndex=0;;){const s=r.VARIABLE_DECODER_REGEX.exec(e);if(!s){r.VARIABLE_DECODER_REGEX.lastIndex=0;break}{let e={name:s[1].trim(),filter:""!==s[2].trim()?s[2].trim():null};t.push(e)}}return t}static variables(e){const r=CurlyBracketParser;return e.match(r.VARIABLE_REGEX).flat()}static isAnyVariableIncluded(e){const r=CurlyBracketParser;return null!==e.match(r.VARIABLE_REGEX)}static includesOneVariableOf(e,r){const t=CurlyBracketParser;for(let s of t.decodedVariables(r))if(e.includes(s.name))return!0;return!1}static _replaceAll(e,r,t){return e.split(r).join(t)}static _runByNode(){return"undefined"!=typeof module&&module.exports}static _runByBrowser(){return!CurlyBracketParser._runByNode()}static _isTreeVariableString(e,r={throw_error_on_false:!1}){const t=!!e.trim().match(/^[^\.]([^\.]*\.[^\.]+)+$/i);if(!t&&r&&r.throw_error_on_false)throw new InvalidTreeVariableStringError(e);return t}static _extractTreeVariable(e,r){CurlyBracketParser._isTreeVariableString(r,{throw_error_on_false:!0});const t=r.split(".");let s=e;for(let e=0;e<t.length;++e){if(!s.hasOwnProperty(t[e]))throw new TreeVariableNotFoundError(`Tree variable not found: '${r}'`);s=s[t[e]]}return s}static _hasTreeProperty(e,r){const t=CurlyBracketParser;t._isTreeVariableString(r,{throw_error_on_false:!0});try{return t._extractTreeVariable(e,r),!0}catch(e){if(e instanceof TreeVariableNotFoundError)return!1;throw e}}}CurlyBracketParser._version="1.3.1",CurlyBracketParser.registered_filters={},CurlyBracketParser.registered_default_vars={},CurlyBracketParser.VARIABLE_DECODER_REGEX=/{{([^{}\|]*)\|?([^{}\|]*)}}/gms,CurlyBracketParser.VARIABLE_REGEX=/{{[^{}]*}}/gms,CurlyBracketParser.VALID_DEFAULT_FILTERS=()=>"undefined"!=typeof LuckyCase?Object.keys(LuckyCase.CASES):[];class FileNotRetrievedError extends Error{constructor(e){super(e),this.name="FileNotRetrievedError"}}class FilterAlreadyRegisteredError extends Error{constructor(e){super(e),this.name="FilterAlreadyRegisteredError"}}class InvalidFilterError extends Error{constructor(e){super(e),this.name="InvalidFilterError"}}class InvalidVariableError extends Error{constructor(e){super(e),this.name="InvalidVariableError"}}class UnresolvedVariablesError extends Error{constructor(e){super(e),this.name="UnresolvedVariablesError"}}class TreeVariableNotFoundError extends Error{constructor(e){super(e),this.name="TreeVariableNotFoundError"}}class VariableAlreadyRegisteredError extends Error{constructor(e){super(e),this.name="VariableAlreadyRegisteredError"}}
//# sourceMappingURL=curly-bracket-parser.min.js.map